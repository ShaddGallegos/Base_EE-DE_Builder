---
- name: Build Execution Environments
  hosts: localhost
  connection: local
  gather_facts: false
  vars:
    environments_dir: "{{ playbook_dir }}/environments"

  pre_tasks:
    - name: Check current SELinux status
      ansible.builtin.command: getenforce
      register: current_selinux_status
      changed_when: false
      failed_when: false

    - name: Set SELinux to permissive for playbook run (only if enforcing)
      become: true
      ansible.posix.selinux:
        policy: targeted
        state: permissive
      when: current_selinux_status.stdout == "Enforcing"
      failed_when: false

    - name: Display SELinux status after change
      ansible.builtin.command: getenforce
      register: selinux_status_after
      changed_when: false
      failed_when: false
    - name: Debug SELinux status after change
      ansible.builtin.debug:
        msg: "SELinux status after change: {{ selinux_status_after.stdout }}"

    - name: Stop and disable firewalld for playbook run
      become: true
      ansible.builtin.service:
        name: firewalld
        state: stopped
        enabled: false
      failed_when: false

    - name: Display firewalld status after change
      ansible.builtin.systemd:
        name: firewalld
      register: firewalld_status_after
      changed_when: false
      failed_when: false
    - name: Debug firewalld status after change
      ansible.builtin.debug:
        msg: "firewalld status after change: {{ firewalld_status_after.status if firewalld_status_after is defined and firewalld_status_after.status is defined else firewalld_status_after }}"
    - name: Add user to podman and docker groups if not already a member
      become: true
      ansible.builtin.user:
        name: "{{ lookup('env', 'USER') }}"
        groups: podman,docker
        append: true
      failed_when: false

    # Ensure newuidmap and newgidmap are installed and setuid root
    - name: Ensure shadow-utils is installed (provides newuidmap/newgidmap)
      become: true
      ansible.builtin.dnf:
        name: shadow-utils
        state: present
      failed_when: false

    - name: Ensure newuidmap is setuid root
      become: true
      ansible.builtin.file:
        path: /usr/bin/newuidmap
        mode: '4755'
      failed_when: false

    - name: Ensure newgidmap is setuid root
      become: true
      ansible.builtin.file:
        path: /usr/bin/newgidmap
        mode: '4755'
      failed_when: false

    # Ensure subuid/subgid ranges for current user
    - name: Ensure subuid range for user
      become: true
      ansible.builtin.command: usermod --add-subuids 100000-165535 {{ lookup('env', 'USER') }}
      changed_when: false
      failed_when: false

    - name: Ensure subgid range for user
      become: true
      ansible.builtin.command: usermod --add-subgids 100000-165535 {{ lookup('env', 'USER') }}
      changed_when: false
      failed_when: false

    - name: Debug subuid/subgid config for user
      ansible.builtin.shell: |
        grep $(whoami) /etc/subuid /etc/subgid
      register: subid_check
      changed_when: false
      failed_when: false
    - name: Debug subuid/subgid config output
      ansible.builtin.debug:
        msg: "subuid/subgid config: {{ subid_check.stdout }}"
    - name: Display user group membership after change
      ansible.builtin.command: id -nG {{ lookup('env', 'USER') }}
      register: user_groups_after
      changed_when: false
      failed_when: false
    - name: Debug user group membership after change
      ansible.builtin.debug:
        msg: "User groups after change: {{ user_groups_after.stdout }}"

    # Clean up contest/ folders in each environment before build
    - name: Remove contest/ folders in each environment for clean build
      become: true
      ansible.builtin.file:
        path: "{{ environments_dir }}/{{ item }}/contest"
        state: absent
      loop: "{{ environment_list | default([]) }}"
      loop_control:
        label: "{{ item }}"
      failed_when: false
    # Ensure Ansible Automation Platform repo is enabled before any dnf install of ansible packages
    - name: Check if required Ansible Automation Platform repo is enabled
      become: true
      ansible.builtin.shell: |
        set -o pipefail
        subscription-manager repos --list-enabled | grep ansible-automation-platform-2.5-for-rhel-9-x86_64-rpms
      register: aap_repo_enabled
      changed_when: false
      failed_when: false

    - name: Enable Ansible Automation Platform repo if not enabled
      become: true
      ansible.builtin.command: subscription-manager repos --enable=ansible-automation-platform-2.5-for-rhel-9-x86_64-rpms
      when: aap_repo_enabled.rc != 0
      changed_when: aap_repo_enabled.rc != 0
      failed_when: false

    - name: Ensure python3.12 and python3.12-pip are installed (dnf)
      become: true
      ansible.builtin.dnf:
        name:
          - python3.12
          - python3.12-pip
        state: present
      failed_when: false

    - name: Ensure 'alternatives' is installed (dnf)
      become: true
      ansible.builtin.dnf:
        name: alternatives
        state: present
      failed_when: false

    - name: Set python3.12 as the default python3 using alternatives
      become: true
      community.general.alternatives:
        name: python3
        path: /usr/bin/python3.12
      failed_when: false

    - name: Add alias for python3 to python3.12 in user's .bashrc
      ansible.builtin.lineinfile:
        path: "{{ lookup('env', 'HOME') }}/.bashrc"
        line: "alias python3=python3.12"
        create: true
        mode: '0644'
      failed_when: false

    - name: Source .bashrc to enable python3 alias in current session
      ansible.builtin.shell: |
        source ~/.bashrc
        python3 --version
      register: python3_alias_check
      changed_when: false
      failed_when: false
    - name: Debug python3 alias after sourcing .bashrc
      ansible.builtin.debug:
        msg: "python3 version after sourcing .bashrc: {{ python3_alias_check.stdout }}"

    - name: Display python3 version after alternatives change
      ansible.builtin.command: python3 --version
      register: python3_version_after
      changed_when: false
      failed_when: false
    - name: Debug python3 version after alternatives change
      ansible.builtin.debug:
        msg: "python3 version after alternatives change: {{ python3_version_after.stdout }}"

    - name: Ensure python3.12 is enabled for current session
      ansible.builtin.shell: |
        export PATH="/usr/bin:$PATH"
        hash -r
        python3 --version
      register: python3_version_check
      changed_when: false
      failed_when: false
    # --- Environment and Dependency Checks ---
    - name: Check SELinux status
      ansible.builtin.command: getenforce
      register: selinux_status
      changed_when: false
      failed_when: false

    - name: Warn if SELinux is enforcing
      ansible.builtin.debug:
        msg: "WARNING: SELinux is Enforcing. This may cause permission issues. Consider setting to Permissive for troubleshooting."
      when: selinux_status.stdout is defined and selinux_status.stdout == 'Enforcing'

    # --- Check and Install Ansible/ansible-builder ---
    - name: Check if ansible-playbook is in PATH
      ansible.builtin.command: which ansible-playbook
      register: ansible_playbook_path
      changed_when: false
      failed_when: false

    - name: Check if ansible-builder is in PATH
      ansible.builtin.command: which ansible-builder
      register: ansible_builder_path
      changed_when: false
      failed_when: false

    - name: Install ansible if not present (dnf)
      become: true
      ansible.builtin.dnf:
        name: ansible
        state: present
      when: ansible_playbook_path.rc != 0
      failed_when: false

    - name: Install ansible if not present (pip fallback)
      ansible.builtin.pip:
        name: ansible
        extra_args: --upgrade --ignore-installed --user
      when: ansible_playbook_path.rc != 0
      failed_when: false

    - name: Install Ansible development packages via pip
      ansible.builtin.pip:
        name:
          - ansible-core
          - ansible-runner
          - ansible-lint
          - ansible-builder
          - ansible-navigator
          - ansible-pylibssh
          - ansible-compat
        extra_args: --user --upgrade --ignore-installed
        executable: pip3

    - name: Ensure ansible-builder is installed system-wide (dnf)
      become: true
      ansible.builtin.dnf:
        name: ansible-builder
        state: present
      failed_when: false

    - name: Ensure ansible-dev-tools is installed system-wide (dnf)
      become: true
      ansible.builtin.dnf:
        name: ansible-dev-tools
        state: present
      failed_when: false

    - name: Install ansible-builder if not present (pip fallback)
      ansible.builtin.pip:
        name: ansible-builder
        extra_args: --user
      when: ansible_builder_path.rc != 0
      failed_when: false

    # Ensure ~/.local/bin is in PATH for pip installs
    - name: Ensure ~/.local/bin is in PATH for ansible-builder
      ansible.builtin.shell: |
        export PATH="$HOME/.local/bin:$PATH"
        echo $PATH
      register: update_path_result
      changed_when: false
      when: ansible_builder_path.rc != 0
      failed_when: false

    # --- Final dependency check ---
    - name: Fail if ansible-playbook is not found
      ansible.builtin.fail:
        msg: "ansible-playbook is not in PATH. Please install Ansible or fix your PATH."
      when: ansible_playbook_path.rc != 0

    - name: Fail if ansible-builder is not found
      ansible.builtin.fail:
        msg: "ansible-builder is not in PATH. Please install ansible-builder or fix your PATH."
      when: ansible_builder_path.rc != 0

  tasks:
    # Discover all environment directories in environments_dir
    - name: Find all available environments
      ansible.builtin.find:
        paths: "{{ environments_dir }}"
        file_type: directory
        excludes: ".*"
      register: all_environments

    - name: Set environment list - Auto-discover all environments
      ansible.builtin.set_fact:
        environment_list: "{{ all_environments.files | map(attribute='path') | map('basename') | list | sort }}"

    - name: Debug discovered environment list
      ansible.builtin.debug:
        msg: "Environments discovered for build: {{ environment_list }}"

    # NEW: Check for execution-environment.yml in each environment
    - name: Check for execution-environment.yml in each environment
      ansible.builtin.stat:
        path: "{{ environments_dir }}/{{ item }}/execution-environment.yml"
      register: ee_yml_check
      loop: "{{ environment_list }}"

    - name: Fail if execution-environment.yml is missing
      ansible.builtin.fail:
        msg: "Missing execution-environment.yml in {{ environments_dir }}/{{ item.item }}"
      loop: "{{ ee_yml_check.results }}"
      when: not item.stat.exists
      loop_control:
        label: "{{ item.item }}"


    # Debug build command and PATH for each environment

    - name: Prepare /tmp build context for each environment
      ansible.builtin.shell: |
        rm -rf /tmp/ee-build-{{ item }}
        mkdir -p /tmp/ee-build-{{ item }}
        cp -a {{ environments_dir }}/{{ item }}/* /tmp/ee-build-{{ item }}/
      loop: "{{ environment_list }}"
      loop_control:
        label: "{{ item }}"
      changed_when: true
      failed_when: false

    - name: Show build command and PATH for each environment
      ansible.builtin.shell: |
        echo "PATH before build: $PATH"
        echo "Building environment: {{ item }}"
        echo "PATH: $PATH | Building: {{ item }} | Command: ansible-builder build --build-arg ANSIBLE_GALAXY_CLI_COLLECTION_OPTS=--ignore-certs --container-runtime {{ container_runtime | default('podman') }} --file /tmp/ee-build-{{ item }}/execution-environment.yml --tag {{ item }}:latest --verbosity 1"
      environment:
        PATH: "{{ lookup('env', 'HOME') }}/.local/bin:/usr/bin:/bin:/usr/sbin:/sbin:{{ lookup('env', 'PATH') }}"
      register: debug_build_env
      loop: "{{ environment_list }}"
      changed_when: false
      failed_when: false

    - name: Build execution environments in /tmp
      ansible.builtin.shell: |
        ansible-builder build \
          --prune \
          --build-arg ANSIBLE_GALAXY_CLI_COLLECTION_OPTS=--ignore-certs \
          --container-runtime {{ container_runtime | default('podman') }} \
          --file /tmp/ee-build-{{ item }}/execution-environment.yml \
          --tag {{ item }}:latest \
          --verbosity 1
      args:
        chdir: "/tmp/ee-build-{{ item }}"
      environment:
        PATH: "{{ lookup('env', 'HOME') }}/.local/bin:/usr/bin:/bin:/usr/sbin:/sbin:{{ lookup('env', 'PATH') }}"
      loop: "{{ environment_list }}"
      register: build_results
      failed_when: false


    # NEW: Optional build summary and error reporting
    - name: Display build results
      ansible.builtin.debug:
        msg: |
          Build result for {{ item.item }}:
            rc: {{ item.rc }}
            stdout: {{ item.stdout }}
            stderr: {{ item.stderr }}
      loop: "{{ build_results.results }}"
